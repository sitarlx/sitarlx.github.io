---
published: true
---
After reading “No Silver Bullet” by Frederick P. Brooks, Jr, “Cherry-Picking and the Scientific Method” by George V. Neville-Neil, and “Why Google Stores Billions of Lines of Code in a Single Repository” by Rachel Potvin and Josh Levenberg, it can be concluded that there is in fact no silver bullet of software. Both the cherry picking and the google monolithic repository articles help reinforce why this is so.
One of Brooks reasonings for why software does not have a “silver bullet” yet is due to the changeability of software. Software never remains in the same state as it was first built in. Users constantly want to add new desires and features which will always bring about new errors, complications and security measures that then must be factored in. The way George recommends attacking this is by “mirroring the scientific method” (33). He claims that you should take your theory and formulate one or more hypotheses about the problem. Then, test these hypotheses in order to find bugs and see whether the hypothesis is simply true or false. The positive aspect of this is your code is improving and you are seeing which hypothesis are solving your problem at hand. The negative aspect of this is the more hypotheses and tests you run, the more problems you run into which only creates more hypotheses and tests to fix those newly made problems. It is a never-ending process but is a necessary evil. This too can be seen in Potvin and Levenberg’s article on Google’s mono lithic repository. 
At the beginning of the software, google believed they had found their “silver bullet”. But as every other programmer does, they came into problems along their way which forced them create new hypotheses and tests which lead to manipulation and changing in their believed to be “silver bullet”. They first added Piper and CitC (Clients in the Cloud) for software engineers, so they had a workflow to follow. Similarly to Git, the users sync their workspace to repo, write code, review code, then commit it. Piper was just more beneficial to use over Git for a monolithic repository. Trunk-based development was also adopted to “avoid the painful merges” (82) from different branches. Google workflow was then added which was an “automated testing infrastructure” that rebuilds all affected dependencies on every committed change in the repo. If this change created “widespread build breakage” the system would then revert the previous change. Even after that, they still didn’t have their silver bullet. They also added “Rosie” in order to preform “large-scale cleanups and code changes” every single night to do away with bad or dead code. Changeability in software is inevitable.
The fact that there is no silver bullet for software is quite exciting. It leaves the field open for endless progress. The changeability and complexity of code always keep you wanting more. It’s similar to Legos and how you can infinitely build and build but as soon as you want to remove one piece or change one piece, you may have to change the whole nature and structure of your building. Changing one piece of code, could potentially lead to so many other problems and that is what makes software so intriguing because there truly is no right way to do it. Every success and failure turn into more knowledge and progress in field of software.  Brooks stated that “the anomaly is not that software progress is so slow, but that computer hardware progress is so fast” (11). Once software progress turns on the after burners and surpasses the desire to progress hardware, the sky is the limit.
